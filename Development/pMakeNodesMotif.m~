% pMakeNodesMotif inserts a known motif into the model

      fprintf('Current node is %d\n', n);
Node(n)
      fprintf('Nucleotide %s%s is part of motif %s\n', File.NT(a).Base, File.NT(a).Number, File.Nucl(a).Motif.Name);

File.Nucl(a).Motif(1)

      ModelIndex = File.Nucl(a).Motif(1).Index;

      Indices = File.Nucl(a).Motif(1).Indices;

      [y,p] = sort(Indices);               % some IL's are rotated 180 degrees

      [MotifNode,Truncate] = pMakeModelFromSearchSaveFile(File.Motifs(ModelIndex).Name,0,0);

      MotifNode = MotifNode(2:end);        % omit Initial node; awkward
      if strcmp(MotifNode(end).LeftLetter,'*'),
        MotifNode = MotifNode(1:(end-1));  % remove artificial hairpin from IL
      end

      for nn = 1:length(MotifNode),
%MotifNode(nn)
%[a B]
        Node(n+nn) = MotifNode(nn);
        Node(n+nn).nextnode = n+nn+1;
        Node(n+nn).LeftIndex = Node(n+nn).LeftIndex + a - 1;
        Node(n+nn).RightIndex = B - MotifNode(nn).LeftIndex + 1;  % kluge!
        if ~isempty(Node(n+nn).MiddleIndex),
          Node(n+nn).MiddleIndex = Node(n+nn).MiddleIndex + double(a);
        end
        Node(n+nn).Comment = [' // Node from model: ' File.Motifs(ModelIndex).Name ' for nucleotide ' File.NT(a).Base num2str(File.NT(a).Number) ' ' Node(n+nn).Comment];

Node(n+nn)
%pause
      end

      n = n + length(MotifNode);

      if strfind(File.Motifs(ModelIndex).Name,'_HL'),
        EndLoop = 1;
      else
        % reset counters to move just beyond the current motif
        % because of how internal loops can be rotated 180 degrees,
        % we need to look at the ends of each strand 
        B = max(File.Nucl(a).Motif(1).Indices([Truncate - 1 end])) - 1;
        a = min(File.Nucl(a).Motif(1).Indices([Truncate - 1 end])) + 1;
      end
